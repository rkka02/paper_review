1) 디스코드에서 채팅 기록 불러오기 되냐?

됨.

봇 토큰으로 Discord REST API 호출하면 특정 채널의 최근 메시지들을 가져올 수 있어.

권한은 최소한:

View Channel

Read Message History

“메시지 내용”을 읽는 건(이벤트 수신) Message Content Intent가 필요할 때가 많고,

“REST로 메시지 히스토리 가져오기”는 권한/토큰만 있으면 되는 편이야.

근데 중요한 건:
히스토리만 믿고 매번 LLM에 넣으면 토큰 지옥 + “어떤 메시지가 ‘우리 에이전트 대화’인지” 필터링이 어려워져.

그래서 보통은 이렇게 해.

2) 불규칙 텀 “자기들끼리 대화”를 제대로 짜는 정석 구조
핵심 구성

Bot (입력/감지 + 상태 관리 트리거) 1개

Worker (실제 LLM 호출/내부 작업) 1개

Webhook (페르소나별 출력) 여러 개 or 1개(메시지마다 username/avatar 바꿈)

Supabase DB = 대화 상태의 정본

DB에 반드시 있어야 하는 것

threads 테이블: 대화 세션(토론방/스레드) 단위

thread_id, channel_id, is_active, topic, next_speaker, last_message_id, last_turn_at, budget_tokens, cooldown_until …

turns 테이블: 한 턴씩 누적 저장

thread_id, speaker(hikari/rei/tsugumi), content, created_at, source(human/agent), discord_message_id

이렇게 하면 디스코드에서 기록이 지워지거나 스크롤이 밀려도 너의 시스템은 맥락을 잃지 않음.

3) “불규칙한 시간 텀”은 어떻게 만들냐?

불규칙은 보통 2가지 의미가 섞여 있어:

A) 스케줄은 주기적, 실행은 확률/조건 기반 (추천)

예: 2분마다 워커가 체크하는데,

마지막 턴 이후 5~10분 랜덤 경과했고

현재 큐 여유 있고

예산 남아있고

토론이 “끝난 상태”가 아니면
→ 다음 턴 하나 생성

이 방식이 안정적이야. “완전 랜덤”이 아니라 “랜덤처럼 보이게” 만들 수 있음.

B) 진짜 랜덤 시각에 예약 (비추천)

“다음 실행 시간을 아예 랜덤으로 예약해두는” 방식도 가능은 한데,
장애/재시작/중복 실행 처리까지 고려하면 오히려 복잡해져.

4) 디스코드 기록을 맥락으로 쓰려면 “어떤 범위까지” 읽을지

불규칙 대화에서 맥락은 보통 3층으로 나눠서 관리하는 게 제일 좋음:

장기 메모리(요약): thread의 “현재까지 결론/쟁점/합의/미해결” 요약 10~20줄

최근 turns(원문): 마지막 5~20턴 정도(토큰 예산에 맞춰)

외부 컨텍스트: 논문 메타/너의 내부 DB 상태/도구 결과

디스코드 채팅 히스토리는 “3)”나 “2)”가 DB에서 유실됐을 때 복구용으로만 쓰는 게 베스트.

5) 봇 하나로 될까?

된다. 오히려 봇은 하나가 정답이야.

봇 여러 개 = 운영 3배, 권한/토큰/장애 3배

봇 하나 + 웹훅(또는 username/avatar override) = “여러 명처럼 보이기” + 운영은 1배

그리고 “자기들끼리 대화”도 실제론:

서버가 턴을 생성하고

웹훅으로 발화만 분장해서 채널에 찍는 거라
봇이 여러 개일 이유가 거의 없어.

6) 제일 위험한 함정: 무한 루프 + 비용 폭발

불규칙 대화는 특히 이거 터지기 쉬워서,
아예 룰을 박아야 해.

추천 안전장치:

max_turns_per_day (예: 30)

max_turns_per_thread (예: 200)

cooldown_until (최소 10분)

“새 정보 없으면 종료” 규칙

“토론 목표 달성하면 종료” 규칙

“인간 메시지 들어오면 다음 턴은 무조건 ‘응답’만 하고, 자기들끼리 토론은 잠깐 멈춤” 규칙

7) 구현 흐름을 아주 구체적으로 쓰면

워커(크론/루프)가 주기적으로 threads 중 is_active=true 조회

각 thread에 대해 “지금 턴 생성할지” 판단(랜덤+조건)

생성한다면:

DB에서 최근 turns + 요약 로드

다음 speaker 선택(규칙 기반)

LLM 호출 → 새 turn 생성

turn 저장

디스코드 webhook으로 발화(페르소나 아바타)

last_turn_at, next_speaker 업데이트

(옵션) N턴마다 요약 업데이트